---
title: "Haskell Through Example: ReaderT"
date: 04 Mar 2019
published: false
---



## Example 1

Suppose we have a config object of some sort, like this:

{% highlight haskell %}
data Config = Config
  { functionName       :: String
  , functionTimeout    :: Int
  , functionPermission :: Role
  , functionMemorySize :: Int
  }
  
data Role = Admin | User
{% endhighlight %}

Being the pure functional zealots that we are, we don't want to store this as a global, mutable object. So the answer, of course, is to pass this object around and read the values from it when we want to. But this isn't nice. It's not nice because we may be several function calls deep, to have passed this object all the way down with no other aim than to call it at the bottom of the stack. Morever it gets worse when we realise we don't actually care about half the stuff on this object - we just want to query the timeout and memory size, right?

Now we've heard about these things called `Reader` and `ReaderT` that people like to build tall towers out of, and we know we want a function that queries only certain aspects of this `Config` object. So let's write a function that does that, as a `ReaderT`.

{% highlight haskell %}
import Control.Monad.Trans.Reader
{% endhighlight %}

First things first, import this black magic. From this we have our data type `ReaderT` in scope, which means we can write our function.

{% highlight haskell %}
mkQuery :: Monad m => ReaderT Config m [Int]
mkQuery = do
  timeout    <- asks functionTimeout
  memorySize <- asks functionMemorySize
  return [timeout, memorySize]
{% endhighlight %}

Okay, okay. So we've got a function that talks the talk - it says it `makesAQuery` and it is of this fancy `ReaderT` type. Its environment is our `Config` data type and it returns a list of `Int`s. But does it walk the walk? What does it actually do?

Well, it just asks for `functionTimeout` and `functionMemorySize` from `Config`. Once it has them, it returns them in a list together. Notice we've not bothered passing anything into this function because the `ReaderT` type is actually deceptive. It's type is 

{% highlight haskell %}
r -> m a
{% endhighlight %}

That is, `ReaderT` is itself a function. Which means our `mkQuery` function is actually awaiting a value. We will come back to this.

One of the nice things about `mkQuery` is that it is declarative in nature - we don't have to care about `Config` at all, we just ask for two fields of it. So now we might use it in the following way.

{% highlight haskell %}
main :: IO ()
main = do
  let config = Config "twitter-bot-function" 360 Admin 100

  queryResult <- runReaderT myQuery config

  print queryResult
{% endhighlight %}

Which will print out 

{% highlight haskell %}
[360, 10]
{% endhighlight %}

And we will look into the mysterious `runReaderT` soon.

## Example 2





So how does `runReaderT` work? Recall that the type of `ReaderT` is

{% highlight haskell %}
r -> m a
{% endhighlight %}

So we can safely replace

{% highlight haskell %}
Monad m => ReaderT A m B
{% endhighlight %}

with

{% highlight haskell %}
A -> m B
{% endhighlight %}

i.e. this is a function that takes some `A` and returns some `B` in some monad, which we've called `m` as a mnemonic. This is all very abstract. `runReaderT` is the thing that goes into a specific `ReaderT` and pulls out this `r -> m a` function. This is because `runReaderT` is the label in the record,

{% highlight haskell %}
newtype ReaderT = ReaderT { runReaderT :: r -> m a }
{% endhighlight %}

We give `runReaderT` a reader and it gives us back a `r -> m a`.

{% highlight haskell %}
theNameOfTheWorld :: Monad m => ReaderT Env m String

:t runReaderT theNameOfTheWorld
{% endhighlight %}

which will give us

{% highlight haskell %}
Monad m => Env -> m String
{% endhighlight %}

Now, we just need to apply an `Env` and we will get our `m String` back.

{% highlight haskell %}
runReaderT theNameOfTheWorld theWorld
{% endhighlight %}

And with `bind`,

{% highlight haskell %}
name <- runReaderT theNameOfTheWorld theWorld
{% endhighlight %}

we can successfully extract the name of the world.






{% highlight haskell %}
module Main where

import Control.Monad.Trans.Reader

data Config = Config 
  { rootPassword :: Text
  , user         :: User 
  } deriving (Eq, Show)

data User = User 
  { name     :: Text
  , password :: Text
  , address  :: Text
  } deriving (Eq, Show)

myQuery :: Monad m => ReaderT Config m [Text]
myQuery = do
  rootPword   <- asks rootPassword
  userName    <- asks $ name . user
  userAddress <- asks $ address . user

  return [rootPword, userName, userAddress]

main :: IO ()
main = do
  let c = Config "password" (User "Pompeii" "Rome")

  query <- runReaderT myQuery c

  print query
{% endhighlight %}
