---
title: "Haskell Through Example: ReaderT"
date: 04 Mar 2019
published: true
---

## 

Suppose we have a config object of some sort, like this:

{% highlight haskell %}
data Config = Config
  { functionName       :: String
  , functionTimeout    :: Int
  , functionPermission :: Role
  , functionMemorySize :: Int
  }
  
data Role = Admin | User
{% endhighlight %}

Being the pure functional zealots that we are, we don't want to store this as a global, mutable object. So the answer, of course, is to pass this object around and read the values from it when we want to. But this isn't nice. It's not nice because we may be several function calls deep, to have passed this object all the way down with no other aim than to call it at the bottom of the stack. Morever it gets worse when we realise we don't actually care about half the stuff on this object - we just want to query the timeout and memory size, right?

Now we've heard about these things called `Reader` and `ReaderT` that people like to build tall towers out of, and we know we want a function that queries only certain aspects of this `Config` object. So let's write a function that does that, as a `ReaderT`.

{% highlight haskell %}
import Control.Monad.Trans.Reader
{% endhighlight %}

First things first, import this black magic. From this we have our data type `ReaderT` in scope, which means we can write our function.

{% highlight haskell %}
mkQuery :: Monad m => ReaderT Config m [Int]
mkQuery = do
  timeout    <- asks functionTimeout
  memorySize <- asks functionMemorySize
  return [timeout, memorySize]
{% endhighlight %}

Okay, okay. So we've got a function that talks the talk - it says it `makesAQuery` and it is of this fancy `ReaderT` type. Its environment is our `Config` data type and it returns a list of `Int`s. But does it walk the walk? What does it actually do?

Well, it just asks for `functionTimeout` and `functionMemorySize` from `Config`. Once it has them, it returns them in a list together. Notice we've not bothered passing anything into this function because the `ReaderT` type is actually deceptive. It's type is 

{% highlight haskell %}
r -> m a
{% endhighlight %}

That is, `ReaderT` is itself a function. Which means our `mkQuery` function is actually awaiting a value. We will come back to this.

One of the nice things about `mkQuery` is that it is declarative in nature - we don't have to care about `Config` at all, we just ask for two fields of it. So now we might use it in the following way.

{% highlight haskell %}
main :: IO ()
main = do
  let config = Config "twitter-bot-function" 360 Admin 100

  queryResult <- runReaderT myQuery config

  print queryResult
{% endhighlight %}

Which will print out 

{% highlight haskell %}
[360, 10]
{% endhighlight %}

And we will look into the mysterious `runReaderT` soon.

## 

`ReaderT` helps us write less code. More specifically, it helps us write fewer function parameters. And believing the aphorism that less code means less bugs, we are eager to see how.

So we have this config type,

{% highlight haskell %}
data CarConfig = CarConfig
  { fuel              :: FuelType
  , timeBeforeService :: Int
  }
  
data FuelType = Electric | Petrol | Diesel | Hydrogen
{% endhighlight %}

Without `ReaderT` whenever we want to pull some value from this config, we have to pass the config as an explicit parameter.

{% highlight haskell %}
calculateFuelConsumption :: Config -> AvgSpeed -> CarWeight -> Int
calculateFuelConsumption config avgSpeed = ... fuel config ...

type AvgSpeed  = Int
type CarWeight = Int
{% endhighlight %}

This will become tiresome quickly, so what we can do is wrap our code in a `ReaderT`, which will provide implicit scope of the `Config` object.




{% highlight haskell %}
top' :: Config -> String
top' c = middle' c

middle' :: Config -> String
middle' c = bottom' c

bottom' :: Config -> String
bottom' c = password c
{% endhighlight %}

{% highlight haskell %}

print $ top' c
{% endhighlight %}






{% highlight haskell %}
import Control.Monad.Trans.Reader

data Config = Config { password :: String }

top :: Monad m => ReaderT Config m String
top = middle

middle :: Monad m => ReaderT Config m String
middle = bottom

bottom :: Monad m => ReaderT Config m String
bottom = asks password
{% endhighlight %}

{% highlight haskell %}
let c = Config "password1234"
res <- runReaderT top c
print res
{% endhighlight %}






So how does `runReaderT` work? Recall that the type of `ReaderT` is

{% highlight haskell %}
r -> m a
{% endhighlight %}

So we can safely replace

{% highlight haskell %}
Monad m => ReaderT A m B
{% endhighlight %}

with

{% highlight haskell %}
A -> m B
{% endhighlight %}

i.e. this is a function that takes some `A` and returns some `B` in some monad, which we've called `m` as a mnemonic. This is all very abstract. `runReaderT` is the thing that goes into a specific `ReaderT` and pulls out this `r -> m a` function. This is because `runReaderT` is the label in the record,

{% highlight haskell %}
newtype ReaderT = ReaderT { runReaderT :: r -> m a }
{% endhighlight %}

We give `runReaderT` a reader and it gives us back a `r -> m a`.

{% highlight haskell %}
theNameOfTheWorld :: Monad m => ReaderT Env m String

:t runReaderT theNameOfTheWorld
{% endhighlight %}

which will give us

{% highlight haskell %}
Monad m => Env -> m String
{% endhighlight %}

Now, we just need to apply an `Env`, since `Env` is the first parameter of this partially-applied function, and we will get our `m String` back.

{% highlight haskell %}
runReaderT theNameOfTheWorld theWorld
{% endhighlight %}

And with `bind`,

{% highlight haskell %}
name <- runReaderT theNameOfTheWorld theWorld
{% endhighlight %}

we can successfully extract the name of the world into a variable called `name`.






{% highlight haskell %}
module Main where

import Control.Monad.Trans.Reader

data Config = Config 
  { rootPassword :: Text
  , user         :: User 
  } deriving (Eq, Show)

data User = User 
  { name     :: Text
  , password :: Text
  , address  :: Text
  } deriving (Eq, Show)

myQuery :: Monad m => ReaderT Config m [Text]
myQuery = do
  rootPword   <- asks rootPassword
  userName    <- asks $ name . user
  userAddress <- asks $ address . user

  return [rootPword, userName, userAddress]

main :: IO ()
main = do
  let c = Config "password" (User "Pompeii" "Rome")

  query <- runReaderT myQuery c

  print query
{% endhighlight %}
